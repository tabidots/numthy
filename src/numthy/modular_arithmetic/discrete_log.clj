(ns numthy.modular-arithmetic.discrete-log
  (:require [clojure.math.numeric-tower :refer [expt]]
            [numthy.factorization.core :refer [factorize]]
            [numthy.helpers :refer [coprime? isqrt]]
            [numthy.modular-arithmetic.groups :refer [cyclic?]]
            [numthy.modular-arithmetic.utils :refer [chinese-remainder mod-inverse mod-mul mod-pow odd-prime?]]
            [numthy.modular-arithmetic.primitive-roots :refer [primitive-root?]]
            [numthy.modular-arithmetic.multiplicative-order :refer [multiplicative-order]]))

(defn- brute-force
  "Brute-force search for x s.t. α^x ≡ β mod m. Returns nil if G = (ℤ/mℤ,×) is not
  cyclic, if β ∉ G, or if there is no solution."
  [α β m]
  (when (and (cyclic? m) (coprime? β m))
    (->> (rest (range m))
         (filter #(= β (mod-pow α % m)))
         first)))

(defn- baby-step-giant-step
  "Uses the baby-step giant-step algorithm to compute the discrete logarithm of β
  to the base α mod p; i.e., the positive integer x ∈ G (ℤ/pℤ,×) s.t. α^x ≡ β mod p.
  G must be cyclic, or otherwise ⟨g⟩, the subgroup generated by α, must be cyclic.
  β must ∈ G or ⟨g⟩ (by being coprime to p). There must be a solution x.
  If any of these conditions are false, the function returns nil."
  ;; p is used as the variable for modulus here only to avoid conflict with `m` from the algorithm.
  ;; However, the algorithm does not require a prime modulus. With reference to HAC, 3.56 & 3.58
  [α β p]
  (if (= α β) 1 ;; Sanity check
    (when-let [n (if (odd-prime? p) (dec p)
                   (multiplicative-order α p))] ;; n is the order of G or ⟨g⟩, whichever is cyclic
      (when (coprime? β p)
        (let [m     (inc (isqrt n))
              table (reduce (fn [res j]
                              (assoc res (mod-pow α j p) j))
                            (sorted-map) (range m))
              base  (-> α (mod-inverse p) (mod-pow m p))] ;; α^-m mod p = (inv of a)^m mod p
          (->> (range m)
               (keep (fn [i]
                       (let [γ (mod-mul β (mod-pow base i p) p)]
                         (when-let [j (get table γ)]
                           (+ (* i m) j)))))
               first))))))

(comment
  "Example 3.58 from Handbook of Applied Cryptography: log_3(57) mod 113"
  (baby-step-giant-step 3 57 113)
  "Verify this by checking 3^100 ≡ 57 mod 113"
  (mod-pow 3 100 113))

(defn- pollard-rho
  "Uses Pollard's rho algorithm to compute the discrete logarithm of β to the base α
  mod p; i.e., the positive integer x ∈ G (ℤ/pℤ,×) s.t. α^x ≡ β mod p.
  ord_p(α) (the number of elements in the subgroup of G generated by α) must be prime.
  If it is not, or if there is no solution x, the function returns nil."
  ;; With reference to HAC, 3.60 & 3.61
  [α β p]
  (if (= α β) 1
    (when-let [n (multiplicative-order α p)]
      (when (and (odd-prime? n) (coprime? β p))
        (let [next-step #(let [{x :x a :a b :b} %]
                           (condp = (mod x 3)
                             1 {:x (mod-mul β x p) :a a               :b (mod (inc b) n)}
                             0 {:x (mod-pow x 2 p) :a (mod-mul 2 a n) :b (mod-mul 2 b n)}
                             2 {:x (mod-mul α x p) :a (mod (inc a) n) :b b}))
              ;; ↓ The 0th iteration (i = 0) is a trivial case where x_i = x_2i
              steps (drop 1 (iterate next-step {:x 1 :a 0 :b 0}))]
          (reduce (fn [res step]
                    (let [{x-2i :x a-2i :a b-2i :b} step] ;; Not the most accurate naming but simplifies things later
                      (if-let [i (get res x-2i)]
                        ;; If x_i already exists in the map, then m is actually the 2*ith iteration
                        ;; and we've found a cycle.
                        (let [r (mod (- (:b i) b-2i) n)]
                          ;; ↓ return r^-1 * (a_2i - a_i) mod n or nil if r = 0
                          (reduced (when (pos? r)
                                     (mod-mul (mod-inverse r n)
                                              (mod (- a-2i (:a i)) n)
                                              n)))) ;; Returns nil if algo fails here
                        ;; If x_i doesn't already exist in the map, no cycle found yet.
                        (assoc res x-2i step))))
                  {} steps))))))

(comment
  "Example 3.61 from Handbook of Applied Cryptography: log_2(228) mod 383"
  (pollard-rho 2 228 383)
  "Verify this by checking 2^110 ≡ 228 mod 383"
  (mod-pow 2 110 383))

(defn- prime-factor->congruence
  "Extremely ugly function to take care of the inner loop of Pollig-Hellman.
  Given a prime factor and power of n, {q_i}^{e_i}, find an x_i mod {q_i}^{e_i}
  that is congruent with log_α(β) mod p. Return [x_i {q_i}^{e_i}]."
  [α β p n q e]
  (let [a     (mod-pow α (/ n q) p)
        qjs   (->> (range (inc e))
                   (map #(mod-pow q % p))
                   (cons 0)        ;; Yields [0 q^0 q^1 q^2 ...]
                   (partition e 1) ;; Yields ((0 q^0 q^1) (q^0 q^1 q^2) (q^1 q^2 q^3))
                   (apply map #(hash-map :prev %1 :cur %2 :next %3)))
                   ;; ↑ Clever way to avoid having to mess with array indices
                   ;; ({:cur 1 :prev 0 :next q^1} {:cur q^1 :prev 1 :next q^2} ...)
        ;; Step through every iteration of q^e for all values from 0 to e
        ;; and compute gamma_j, overline-beta_j, ell_j, and ultimately x_j.
        ;; This is complicated because the intermediate values rely on different
        ;; steps of the values.
        table (reduce (fn [res qj]
                        (let [prev  (peek res)
                              g (-> (mod-pow α (*' (prev :l) (:prev qj)) p)
                                    (*' (prev :g))
                                    (mod p))
                              b (-> (*' β (mod-inverse g p))
                                    (mod-pow (/ n (:next qj)) p))
                              l (baby-step-giant-step a b p)
                              x (*' l (:cur qj))]
                          (conj res {:g g :l l :x x})))
                      [{:g 1 :l 0 :x 0}]   ;; seed values
                      qjs)
        x     (reduce +' (map :x table))]
    [x (expt q e)]))

(defn- pohlig-hellman
  "Uses the Pohlig-Hellman algorithm to compute the discrete logarithm of β
  to the base α mod p; i.e., the positive integer x ∈ G (ℤ/pℤ,×) s.t. α^x ≡ β mod p."
  ;; With reference to HAC, 3.63 & 3.64
  [α β p]
  (if (= α β) 1
    (when-let [n (if (odd-prime? p) (dec p)
                   (multiplicative-order α p))] ;; n is the order of G or ⟨g⟩, whichever is cyclic
      (when (coprime? β p)
        (try
          (->> (reduce-kv (fn [res q e]
                            (conj res (prime-factor->congruence α β p n q e)))
                          [] (factorize n))
               (chinese-remainder))
          ;; discrete log does not necessarily exist for all intermediate a,b,p
          ;; in the congruence fn!
          (catch NullPointerException e
            nil))))))

(comment
  "Example 3.64 from Handbook of Applied Cryptography: log_71(210) mod 251"
  (pohlig-hellman 71 210 251)
  "Verify this by checking 71^197 ≡ 210 mod 251"
  (mod-pow 71 197 251))

(defn dlog
  "Tries various algorithms to compute the discrete logarithm of β to the base α mod p.
  The modulus need not be prime. Returns nil if there is not or cannot be a solution
  (for example, if the group G is not cyclic), but does not distinguish between the two."
  [α β p]
  (or (pohlig-hellman α β p)
      (pollard-rho α β p)
      (baby-step-giant-step α β p)))

;; https://en.wikipedia.org/wiki/Index_calculus_algorithm
;; https://en.wikipedia.org/wiki/Function_field_sieve
